if #arg == 0 then
   os.exit(0)
end

function scriptPath()
   local str = debug.getinfo(2, "S").source:sub(2)
   return str:match("(.*/)")
end

print(scriptPath())

--
-- Stuff to ensure alphabetic order
-- Taken from http://lua-users.org/wiki/SortedIteration
--
--[[
   Ordered table iterator, allow to iterate on the natural order of the keys of a
   table.

   Example:
]]

function __genOrderedIndex( t )
   local orderedIndex = {}
   for key in pairs(t) do
	  table.insert( orderedIndex, key )
   end
   table.sort( orderedIndex )
   return orderedIndex
end

function orderedNext(t, state)
   -- Equivalent of the next function, but returns the keys in the alphabetic
   -- order. We use a temporary ordered key table that is stored in the
   -- table being iterated.

   local key = nil
   --print("orderedNext: state = "..tostring(state) )
   if state == nil then
	  -- the first time, generate the index
	  t.__orderedIndex = __genOrderedIndex( t )
	  key = t.__orderedIndex[1]
   else
	  -- fetch the next value
	  for i = 1,#t.__orderedIndex do
		 if t.__orderedIndex[i] == state then
			key = t.__orderedIndex[i+1]
		 end
	  end
   end

   if key then
	  return key, t[key]
   end

   -- no more value to return, cleanup
   t.__orderedIndex = nil
   return
end

function orderedPairs(t)
   -- Equivalent of the pairs() function on tables. Allows to iterate
   -- in order
   return orderedNext, t, nil
end

local maria = dofile(scriptPath() .. "sqlite.lua")
maria:process(arg[1])

maria = dofile(scriptPath() .. "mariadb.lua")
maria:process(arg[1])

local description = dofile(arg[1])
local tables = description.tables

-- Write structs
local structfile = io.open(description.name .. ".h", "w")
structfile:write([[
// Generated by LuaSQL
#pragma once

#include <string>
#include <cstdint>
]] .. description.defines .. [[namespace ]] .. description.name ..
   [[
{
using std::string;
typedef uint32_t uint;
typedef int64_t int64;
typedef uint64_t uint64;

]])

for k,v in orderedPairs(tables) do

   -- C++
   structfile:write("struct " .. k .. "\n{\n")
   structfile:write("\tunsigned long long id = 0;\n")

   local toJsonString = ""
   for p,q in orderedPairs(v) do
      -- SQL
      toJsonString = toJsonString .. "\t\t" .. [[ss << "\"]] .. p .. [[\" : \"" << ]] .. p .. " << \"\\\",\" << std::endl;\n";

      -- C++
      -- Write into struct
      if tables[q] ~= nil then
	 if p ~= q then
	    structfile:write("\tunsigned int " .. p .. " = 0;\n")
	 end
      else
	 if q ~= "string" then
	    structfile:write("\t" .. q .. " " .. p .. " = 0;\n")
	 else
	    structfile:write("\t" .. q .. " " .. p .. ";\n")
	 end
      end
   end

   -- Generate toJson
   structfile:write([[

	std::string toJson() const
	{
		std::stringstream ss;
		ss << "{\n";
]] .. toJsonString .. [[
			  ss << "\"id\" : \"" << id << "\"\n";
			  ss << "}\n";
			  return ss.str();
			  }
]])
-- Generate custom methods
for i,f in ipairs(description.structdef) do
   structfile:write(f(k, v))
end

structfile:write("};\n\n")
end
structfile:write("}\n")
structfile:close()

local testfile = io.open(description.name .. "Test.cpp", "w")
testfile:write([[
// Google test suite for the database, generated by LuaSQL
#include <gtest/gtest.h>

#ifndef DATABASE 
#define DATABASE "testdb"
#endif

#ifndef HOST 
#define HOST "localhost"
#endif

#ifndef USER
#define USER "handiserv"
#endif

#ifndef PASSWORD
#define PASSWORD "niugnip"
#endif

#ifndef PORT
#define PORT 13306
#endif

]])

testfile:write("#include \"" .. description.name .. ".h\"\n\nusing namespace " .. description.name .. ";\n\n")

testfile:write([[
class ]] .. description.name .. [[Test : public testing::Test
{
protected:

	]] .. description.name .. "::" .. description.name .. [[ sql;

	std::string getDatabaseName()
	{
		const ::testing::TestInfo* const testInfo = ::testing::UnitTest::GetInstance()->current_test_info();
		const std::string database = "handiserv_" + std::string(testInfo->test_case_name())
			+ "_" + std::string(testInfo->name());

		return database;
	}

	virtual void SetUp() override
	{
		sql.connect(getDatabaseName(), HOST, USER, PASSWORD, PORT);
		sql.init("]] .. description.name .. [[.sql");
	}

	virtual void TearDown() override
	{
		sql.drop();
		sql.close();
	}
};

]])

for k,v in orderedPairs(tables) do
   testfile:write("TEST_F(" .. description.name .. "Test, AddUpdateRemoveQuery" .. k .. ")\n{\n")
   testfile:write("\tstruct " .. k .. " object;\n");
   testfile:write("\tobject.id = -1;\n")
   testfile:write("\tsql.create" .. k .. "(object);\n\n")

   testfile:write("\tASSERT_NE(-1, object.id);\n");

   testfile:write("\tstruct " .. k .. " object2;\n");
   testfile:write("\tsql.get" .. k .. "(object.id, object2);\n\n")

   testfile:write("\tASSERT_EQ(object.id, object2.id);\n");

   testfile:write("\tsql.delete" .. k .. "(object.id);\n")
   testfile:write("\tEXPECT_FALSE(sql.get" .. k .. "(object.id, object2));\n\n")

   -- testfile:write("\tstd::cout << object.toJson() << std::endl;\n")
   testfile:write("}\n\n")
end

testfile:close()

--
-- Plantuml
--

local pumlfile = io.open(description.name .. "Design.puml", "w")

pumlfile:write("@startuml\n\n")
for k,v in orderedPairs(tables) do
   local connectionStr = ""
   local connectionMap = {}
   pumlfile:write([[
class ]] .. k .. "{\n")

   for p,q in orderedPairs(v) do
	  pumlfile:write("\t" .. p .. " : " .. q .. "\n")

	  -- Only add every type once
	  if tables[q] ~= nil and connectionMap[q] == nil then
		 connectionStr = connectionStr .. k .. " -- " .. q .. "\n"
		 connectionMap[q] = true
	  end
   end

   pumlfile:write("}\n" .. connectionStr .. "\n")
end
pumlfile:write("@enduml\n")
pumlfile:close()

