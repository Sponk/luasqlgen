local common = require("common")

local sqlitetypes = {
   string = "text",
   int = "int",
   uint = "int",
   int64 = "int",
   uint64 = "int",
   bool = "int" -- FIXME: Byte?
}

local function type2sqlite(type)
   local result = sqlitetypes[type]
   if result == nil then -- If type was not found, return an ID since it is most likely a table
      return "int"
   end
   return result
end

local sqlitesqltypes = {
   string = "text",
   int = "int",
   uint = "int unsigned",
   int64 = "bigint",
   uint64 = "bigint unsigned",
   bool = "bool" -- FIXME: Byte?
}

function type2sqlitesql(type)
   local result = sqlitesqltypes[type]
   if result == nil then -- If type was not found, return an ID since it is most likely a table
      return "bigint"
   end
   return result
end

local SQLite = {}

function SQLite:process(filename)
   local description = dofile(filename)
   self:processStructs(description)
end

function SQLite:generateStatement(name)
   return "sqlite3_stmt* " .. name .. ";"
end

function SQLite:setStatementArg(name, idx, varname, typedef)

   if(typedef ~= "string") then
      return "sqlite3_bind_" .. type2sqlite(typedef) .. "(" .. name .. ", " .. idx .. ", " .. varname .. ");"
   else
      return "sqlite3_bind_text(" .. name .. ", " .. idx .. ", " .. varname .. ".c_str());"
   end
end

function SQLite:generateInsert(name, targetid)
   return "{int err = sqlite3_step(" .. name.. "); " ..
[[
    // if(err == SQLITE_ROW)
 ]] .. targetid .. [[ = sqlite3_last_insert_rowid(); }
]]
  -- return targetid .. " = " .. name .. "->insert();"
end	  

function SQLite:generateExecute(name)
   return "sqlite3_step(" .. name.. ");"
end	  

function SQLite:getStatementResult(resultname, name, varname, typedef)
   return [[if(]] .. resultname .. [[ == SQLITE_ROW)
{
]] .. varname .. " = sqlite3_column_" .. type2sqlite(typedef) .. "(" .. name ..
   ", getColumnIndex(" .. name .. ", \"" .. varname .. "\"));" ..
[[}]]
end

function SQLite:generateQuery(name, varname)
   return "int " .. varname .. " = sqlite3_step(" .. name.. ");"
end

function SQLite:generateQueryFetchFirst(name, varname)
   return "int " .. varname .. " = sqlite3_step(" .. name.. ");\n\n" ..
   [[
		if(]]..varname..[[ != SQLITE_ROW)
			return false;
]]
end

function SQLite:generateRowLoop(resultname, name)
   --return "for(unsigned int j = 0; j < " .. resultname .. "->row_count() && " .. resultname .. "->next(); j++)"

   return [[while((]] .. resultname .. [[ = sqlite3_step(]] .. name ..[[)) == SQLITE_ROW)]]
end

function SQLite:beginStatement(name)
   return "{int err = sqlite3_prepare_v2(m_database, "
end

function SQLite:endStatement(name)
   return ", -1, &create" .. name .. "Stmt, 0); " 
      .. "if(err != SQLITE_OK) throw "
      .. "std::runtime_error(std::string(\"Could not prepare statement:\") +" ..
					      "sqlite3_errmsg(m_database));}"
		     
end

function SQLite:processStructs(description)
   print("Generating structs...")
   local file = io.open(description.name .. ".h", "w")
   local sqlfile = io.open(description.name .. ".sql", "w")
   local tables = description.tables
   
   file:write([[
// Generated by LuaSQL
#pragma once

#include <string>
#include <cstdint>
#include <sqlite3.h>
#include <exception>
#include <vector>
#include <fstream>
]] .. description.defines .. [[

namespace ]] .. description.name ..
   [[
{
using std::string;
typedef uint32_t uint;
typedef int64_t int64;
typedef uint64_t uint64;

]])

   for k,v in orderedPairs(tables) do

      -- SQL
      sqlfile:write("create table `" .. k .. "` (\n\t`id` int primary key auto_increment")
      
      -- C++
      file:write("struct " .. k .. "\n{\n")
      file:write("\tunsigned long long id = 0;\n")

      local toJsonString = ""
      for p,q in orderedPairs(v) do
	 -- SQL
	 sqlfile:write(",\n\t`" .. p .. "` " .. type2sqlitesql(q) .. " NOT NULL")
	 toJsonString = toJsonString .. "\t\t" .. [[ss << "\"]] .. p .. [[\" : \"" << ]] .. p .. " << \"\\\",\" << std::endl;\n";

	 -- C++
	 -- Write into struct
	 if tables[q] ~= nil then
	    if p ~= q then
	       file:write("\tunsigned int " .. p .. " = 0;\n")
	    end
	 else
	    if q ~= "string" then
	       file:write("\t" .. q .. " " .. p .. " = 0;\n")
	    else
	       file:write("\t" .. q .. " " .. p .. ";\n")
	    end
	 end
      end

      sqlfile:write(");\n\n")

      -- Generate toJson
      file:write([[

	std::string toJson() const
	{
		std::stringstream ss;
		ss << "{\n";
]] .. toJsonString .. [[
		ss << "\"id\" : \"" << id << "\"\n";
		ss << "}\n";
		return ss.str();
	}
]])
      -- Generate custom methods
      for i,f in ipairs(description.structdef) do
	 file:write(f(k, v))
      end

      file:write("};\n\n")
   end


   file:write(
      "\n\nclass " .. description.name .. "\n{\npublic:\n\t" .. description.name  ..
	 [[
(const std::string& db, const std::string& host, const std::string& name, 
				const std::string& password, const unsigned short port)
	{
    	connect(db, host, name, password, port);
    }

]])

   -- Empty default constructor
   file:write("\t" .. description.name .. "() {}\n\n")

   file:write("\t~" .. description.name .. "()\n\t{\n")
   file:write([[
		  if(m_connection != nullptr && m_connection->connected())
		  m_connection->disconnect();
	       ]])
   file:write("\t}\n\n")

   for k,v in orderedPairs(tables) do
      common:generateCreateFunction(self, file, k, v)
      common:generateGetFunction(self, file, k, v)
      common:generateUpdateFunction(self, file, k, v)
      common:generateDeleteFunction(self, file, k, v)
      common:generateQueryFunction(self, file, k, v)
      common:generateSearchFunction(self, file, k, v)
   end
  
   file:write([[

		  void connect(const std::string& db, const std::string& host,
			       const std::string& name, const std::string& password, const unsigned short port)
		  {
		     //sqlite3_shutdown();
		     //if(sqlite3_config(SQLITE_CONFIG_SERIALIZED) != SQLITE_OK)
		     //throw std::runtime_error(std::string("Could not configure thread safety: ") +
		//			      sqlite3_errmsg(m_database));
		     
		  //   sqlite3_initialize();
		     if (sqlite3_open(url, &m_database))
		     throw std::runtime_error(std::string("Could not open database: ") +
					      sqlite3_errmsg(m_database));
		     
		     if(sqlite3_threadsafe() == 0)
		     std::cerr << "SQlite is not compiled as thread safe!" << std::endl;

		     query("PRAGMA journal_mode=WAL");
		  }

		  void execute(const std::string& file)
		  {
		     std::ifstream in(file);
		     if(!in)
		     throw std::runtime_error("Could not open SQL script file!");

		     std::stringstream buf;
		     buf << in.rdbuf();

		     query(buf.str());
		  }

		  void init(const std::string& db)
		  {
		     // Check if tables exist or not
			if(!tableExists("DBInfo"))
		     execute(db);

	       ]])

   for k,v in orderedPairs(tables) do
      common:generateCreateStmt(self, file, k, v)
      common:generateUpdateStmt(self, file, k, v)
      common:generateDeleteStmt(self, file, k, v)
      common:generateQueryStmt(self, file, k, v)
      common:generateGetStmt(self, file, k, v)
      common:generateSearchStmt(self, file, k, v)
   end

   file:write([[	}

void drop()
{
   // Has not really a meaning with SQLite: Just delete the file...
}

void close()
{
   sqlite3_close(m_database); 
   m_database = nullptr;
}

private:

void query(const std::string& q)
{
   char* error = nullptr;
   if(sqlite3_exec(m_database, q.c_str(), nullptr, nullptr, &error) != SQLITE_OK)
   throw std::runtime_error(std::string("Could not access database: ") +
			    error);
}

bool tableExists(const std::string& name)
{
	std::stringstream query;
	query << "SELECT name FROM sqlite_master WHERE type='table' AND name='"
		  << name << "'";

	const auto callback = [](void* data, int argc, char** argv,
							 char** colName) {
		bool* result = reinterpret_cast<bool*>(data);
		*result = (argc > 0);
		return 0;
	};

	char* error = nullptr;
        bool result = false;
	if (sqlite3_exec(m_database, query.str().c_str(), callback, &result, &error) != SQLITE_OK)
		throw std::runtime_error(std::string("Could not access database: ") +
								 error);
	return result;
}

sqlite3* m_database;

]])

file:write("};\n}\n") -- Close file and namespace
file:close()
end

return SQLite
